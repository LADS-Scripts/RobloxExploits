local lplr = game:GetService('Players').LocalPlayer
local mouse = lplr:GetMouse()
local cam = workspace.CurrentCamera

mouse.KeyDown:Connect(function(k)
	if k ~= 'g' then return end

	local run = game:GetService('RunService')
	local mouseDown = false
	local hl = Instance.new('Highlight')


	local rpars = RaycastParams.new()
	rpars.FilterType = Enum.RaycastFilterType.Exclude

	local raycast = function(pos, dir)
		local ignore = {lplr.Character, workspace.Effects}
		local result
		repeat
			rpars.FilterDescendantsInstances = ignore
			result = workspace:Raycast(pos, dir, rpars)
			if result and result.Instance.CanCollide == false then
				table.insert(ignore, result.Instance)
			end
		until not result or result.Instance.CanCollide == true
		return result
	end


	task.spawn(function()
		while not mouseDown and task.wait() do
			hl.Adornee = nil
			hl.Parent =  nil
			local tar = mouse.Target
			if not tar then continue end

			hl.Adornee = tar
			hl.FillColor = string.find(tar.Name, 'Flange') and Color3.new(0, 1, 0) or Color3.new(1,0,0)
			pcall(function()
				hl.Parent =  run:IsStudio() and workspace or game.CoreGui
			end)
		end
	end)

	mouse.Button1Down:Wait()
	mouseDown = true

	local t0 = mouse.Target ~= nil and string.find(mouse.Target.Name, 'Flange') and mouse.Target

	local result0 = raycast(cam.CFrame.Position, mouse.UnitRay.Direction*3000 ) or {}

	if not result0 then
		hl:Destroy()
		return
	end


	mouseDown = false
	task.spawn(function()
		while not mouseDown and task.wait() do
			hl.Adornee = nil
			hl.Parent =  nil
			local tar = mouse.Target
			if not tar then continue end

			hl.Adornee = tar
			hl.FillColor = string.find(tar.Name, 'Flange') and Color3.new(0, 1, 0) or Color3.new(1,0,0)
			pcall(function()
				hl.Parent =  run:IsStudio() and workspace or game.CoreGui
			end)
		end
	end)
	mouse.Button1Down:Wait()
	hl:Destroy()

	local t1 = mouse.Target ~= nil and string.find(mouse.Target.Name, 'Flange') and mouse.Target
	local result1 = raycast(cam.CFrame.Position, mouse.UnitRay.Direction*3000, rpars ) or {}

	local p0 = t0 and t0.Position-t0.CFrame.UpVector*2 or result0.Position+ result0.Normal*2.05
	local p1 = t1 and t1.Position-t1.CFrame.UpVector*2 or result1.Position+ result1.Normal*2.05

	local dist = (p0-p1).Magnitude
	local divBy = 19
	for i = divBy, 5, -.1 do
		if dist%i >6 then
			divBy = i
			break
		end
	end

	local obj0
	if t0 and t1 then
		obj0 = t0
		repeat
			obj0 = obj0.Parent
		until obj0.Parent == workspace.Structures

	end

	local gUp = Vector3.new(0, 1, 0)

	local dir = (p1-p0).Unit
	local upVec = not t0 and result0.Normal or not t1 and result1.Normal or math.abs(gUp:Dot(dir))>.9 and obj0.PrimaryPart.CFrame.UpVector or gUp


	local look = -dir
	local right = upVec:Cross(-dir)
	local prevPipe = t0

	local from = t0 or t1  or result0.Instance or result1.Instance


	for i = 1, math.ceil(dist/divBy) do

		local start = CFrame.fromMatrix(p0+(i-1)*dir*divBy, right, upVec, look)
		local curDist = (start-p1).p.Magnitude
		local ending = CFrame.new( curDist<=21 and p1 or start.p+dir*divBy)*start.Rotation*CFrame.Angles(0, math.pi, 0)

		local mid = (ending.p+start.p)/2

		if curDist<=21 and t1 then
			local args ={
				[1] = "Pipe",
				[2] = {
					[1] = {
						["SnapPart"] = prevPipe,
						["CFrame"] = prevPipe.CFrame
					},
					[2] = {
						["SnapPart"] = t1,
						["CFrame"] = t1.CFrame
					}
				}
			}
			game:GetService("ReplicatedStorage").Shared.Remotes.PlaceStructure:FireServer(unpack(args))
			return
		end


		local pipeFound = false
		local con con = workspace.Structures.ChildAdded:Connect(function(nigga)
			task.wait(.04)
			if nigga.Name ~= 'Pipe' then return end
			local e = os.clock()+2
			repeat task.wait() until nigga.PrimaryPart or os.clock()>e
			task.wait(.03)
			if (nigga.PrimaryPart.Position-mid).Magnitude>5 then return end
			pipeFound = nigga
			con:Disconnect()
		end)

		local args = not prevPipe and {
			[1] = "Pipe",
			[2] = {
				[1] = {
					["BasePart"] = from,
					["CFrame"] = from.CFrame:ToObjectSpace(start)
				},
				[2] = {
					["BasePart"] = from,
					["CFrame"] = from.CFrame:ToObjectSpace(ending)
				}
			}
		} or {
			[1] = "Pipe",
			[2] = {
				[1] = {
					["SnapPart"] = prevPipe,
					["CFrame"] = prevPipe.CFrame
				},
				[2] = {
					["BasePart"] = prevPipe,
					["CFrame"] = CFrame.new()
				}
			}
		}

		--prevPipe.CFrame:ToObjectSpace(ending+Vector3.new(0, .15, 0)+right*math.random(-120, 120)/300+look*math.random(-10, 10)/100)
		local tcf = ending+Vector3.new(0, .15, 0)+right*math.random(-120, 120)/300+look*math.random(-10, 10)/100

		rpars.RespectCanCollide = true
		local downRes = raycast(tcf.Position, upVec*-2.7, rpars)

		if downRes then
			--print(downRes.Instance)
			--local lup = downRes.Normal
			--local llv = -dir
			--local lrv = llv:Cross(lup)
			--tcf = CFrame.fromMatrix(downRes.Position+lup*2.02, lrv, lup, llv)
			tcf = CFrame.new(downRes.Position+downRes.Normal*1.98)*ending.Rotation
		end
		args[2][2].CFrame = (prevPipe or from ).CFrame:ToObjectSpace(tcf)

		game:GetService("ReplicatedStorage").Shared.Remotes.PlaceStructure:FireServer(unpack(args))

		local e = os.clock()+10
		repeat task.wait() until pipeFound or os.clock()>e
		if not pipeFound then break end

		prevPipe = pipeFound.FemaleFlange2
	end
end)

mouse.KeyDown:Connect(function(k)
	if k == 'b' then     
		local buttons = {'SmallButton', 'MediumButton', 'MediumButton', 'LargeButton', 'LargeButton', 'LargeButton'}

		local s = os.time()

		for i, v in next, workspace.Structures:GetDescendants() do
			if v.Name == 'Shield Generator' then
				local dist = game.Players.LocalPlayer.Character.HumanoidRootPart.Position-v.PrimaryPart.Position
				if dist.Magnitude>20 then continue end
				pcall(function()
					math.randomseed(s+i)
					local button = v[ buttons[math.random(1, #buttons)]].ContextButton
					game:GetService("ReplicatedStorage").Shared.Remotes.ContextButton:FireServer(
						button
					)
				end)
			end
		end

	elseif k == 'h' then 
		local toFind = {}

		local charpos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position

		for _, structure in next, workspace.Structures:GetChildren() do

			local pp = structure.PrimaryPart
			if not pp then continue end
			if (charpos-pp.Position).Magnitude>35 then continue end
			if string.find(structure.Name, 'Cap') then continue end

			for _, v in next, structure:GetDescendants() do
				if v:IsA('BasePart') and string.find(v.Name, 'FemaleFlange') then
					--v.Size = Vector3.new(2,2,2)
					--v.Transparency = 0.5
					local add = true

					for _, vv in next, workspace:GetPartsInPart(v) do
						if not structure:IsAncestorOf(vv) then 
							add = false
							break
						end
					end
					if add then
						table.insert(toFind, v)
					end
				end
			end
		end

		local pars = OverlapParams.new()
		pars.FilterType = Enum.RaycastFilterType.Include
		pars.FilterDescendantsInstances = toFind
		local parts = workspace:GetPartBoundsInRadius(game.Players.LocalPlayer.Character.HumanoidRootPart.Position, 18, pars)


		for i, v in next, parts do
			-- Script generated by SimpleSpy - credits to exx#9394
			local args = {
				[1] = "Distributor Cap",
				[2] = {
					["BasePart"] = v,
					["CFrame"] = CFrame.new(0.1552886962890625, -0.4000396728515625, 0.5795516967773438) * CFrame.Angles(-1.5707981586456299, 0.0000013113021850585938, 0.26180127263069153)
				},
				[3] = "FemaleFlange",
				[4] = v
			}

			game:GetService("ReplicatedStorage").Shared.Remotes.PlaceStructure:FireServer(unpack(args))
			task.wait(.4)
		end
		return
	end
end)
