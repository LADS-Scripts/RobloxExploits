local mainmodule

do
	local lplr= game:GetService("Players").LocalPlayer
local plrs = game:GetService("Players")

local snps = false
pcall(function()
if syn then snps = true end
end)



local ffcoc= game.FindFirstChildOfClass
local ffc = game.FindFirstChild


local gameids = {}
do
	gameids.ThoseWhoRemain = 187796008
	gameids.Phantom_Forces = 113491250
	gameids.pf2 = 115272207
	if game.GameId ~= gameids.Phantom_Forces then
		gameids.Phantom_Forces = gameids.pf2
	end
	gameids.Arsenal = 111958650
	gameids.Unit = 327709123
	gameids.Apoc2 = 358276974
	if game.GameId == 184068396 then
		gameids.Aegis= 184068396
	else	
		gameids.Aegis = 1078934163
	end
	gameids.BadBuisness = 1168263273
	gameids.badgay = gameids.BadBuisness
	gameids.Eclipsis = 252475658
	gameids.Lost = 597889174 
	gameids.counterblox = 115797356
	gameids.Attrition = 367058015
	gameids.Jailbreak = 245662005
	gameids.wfyb = 74218984
	gameids.madpaintball2 = 112819343
	gameids.ace = 913400159
	gameids.fireteam = 261612318
	
end

local m = {}
m.getignore = function()
	return {}
end

m.getsettings = function()
	local id = game.GameId
	local setting = {}
	setting.PartSize = 0
	setting.Bindable = {}
	setting.Bindable.BulletDrop = 0
	setting.Bindable.BulletSpeed = 3500
	setting.Bindable.calculation = false
	setting.Bindable.AimAssist = true
	setting.Bindable.ESP = true
	setting.Bindable.EspUpdateTime = 0.15
	setting.Bindable.AutoShoot = false
	setting.Bindable.Headshots = 100
	setting.Bindable.Circle =  120
	setting.Bindable.Radar = true
	setting.Bindable.RadarSize = 175
	setting.Bindable.MaxRaycastDistance = 500
	setting.Bindable.UseMouseMove = true
	setting.Bindable.SmartCircle = true
	setting.Bindable.ShowVelocity = false
	if id == gameids.Apoc2 then
		workspace:WaitForChild('Vehicles')
		setting.Bindable.EspUpdateTime = 2
		setting.Bindable.MaxRaycastDistance = 900
		setting.Bindable.AutoShoot = false
		setting.Bindable.AimAssist = true
		setting.Bindable.BulletSpeed = 10^4
		setting.Bindable.calculation=true
		setting.Bindable.BulletDrop = 0.175
		setting.Bindable.Radar = false
	elseif id == gameids.fireteam then
		setting.Bindable.EspUpdateTime = 2
		setting.Bindable.MaxRaycastDistance = 900
		setting.Bindable.AutoShoot = false
		setting.Bindable.AimAssist = true
		setting.Bindable.BulletSpeed = 10^4
		setting.Bindable.calculation= true
		setting.Bindable.BulletDrop = 0.075
		setting.Bindable.Radar = false
	elseif id == gameids.Jailbreak then
		setting.Bindable.Radar = false
		setting.Bindable.AimAssist = true
	elseif id == 187796008 then -- those who remain
		setting.Bindable.MaxRaycastDistance = 200
		setting.Bindable.AutoShoot = true
		setting.Bindable.AimAssist = true
		setting.Bindable.BulletSpeed = 1500
		setting.Bindable.calculation=true
		setting.Bindable.Radar = false
	elseif game.GameId == gameids.badgay then
		setting.Bindable.AutoShoot = false
		setting.Bindable.calculation = true
		setting.Bindable.BulletSpeed = 2700
		setting.Bindable.AimAssist = true
		setting.Bindable.BulletDrop = 0.24
		setting.Bindable.Radar = false
		setting.Bindable.EspUpdateTime = 0.4
	elseif game.GameId == gameids.Phantom_Forces then
		setting.Bindable.calculation = true
		setting.Bindable.BulletSpeed = 2100
		setting.Bindable.AimAssist = true
		setting.Bindable.BulletDrop = 0.2
		setting.Bindable.ESP = true
		setting.Bindable.Circle =  85
		setting.Bindable.Headshots = 67
		setting.PartSize = 0.22
	elseif game.GameId == gameids.Arsenal then
		setting.Bindable.Radar = false
		setting.Bindable.UseMouseMove = false
		setting.Bindable.AimAssist = true
	elseif game.GameId == gameids.Lost then
		setting.Bindable.UseMouseMove = false
		setting.Bindable.Radar = true
		setting.Bindable.RadarSize = 400
		setting.Bindable.calculation = true
		setting.Bindable.BulletSpeed = 3000
		setting.Bindable.BulletDrop = 0.15
	elseif game.GameId == gameids.counterblox then
		setting.Bindable.UseMouseMove = false
		setting.Bindable.Radar = true
		setting.Bindable.RadatSize = 200
		setting.Bindable.AimAssist = true
		setting.PartSize = 0.4
	elseif id == gameids.Attrition then
		setting.Bindable.UseMouseMove = false
		setting.Bindable.Radar = false
		setting.Bindable.RadatSize = 200
		setting.Bindable.AimAssist = true
		setting.Bindable.calculation = true


		spawn(function()
			local gunname
			local bspeed = 3100
			while wait(.3) do
				local succ, error = pcall(function()
					if  lplr.Character and ffcoc(lplr.Character, 'Tool') and ffc(ffcoc(lplr.Character, 'Tool') , 'Settings')then
						if ffcoc(lplr.Character, 'Tool').Name ~= gunname then
							--print('setting1')
							bspeed = require( ffc(ffcoc(lplr.Character, 'Tool') , 'Settings') ).BulletSpeed
							setting.Bindable.BulletSpeed = bspeed
							print('set')
						end

						gunname = ffcoc(lplr.Character, 'Tool').Name
					end
				end)
				if not succ then print(error) end
			end
		end)

	elseif id == gameids.Eclipsis then
		setting.Bindable.UseMouseMove = true
		setting.Bindable.Radar = false
		setting.Bindable.RadatSize = 200
		setting.Bindable.AimAssist = true
		setting.Bindable.calculation = false
		setting.Bindable.MaxRaycastDistance = 250
		setting.Bindable.EspUpdateTime = 1
	elseif id == gameids.ace then
		setting.Bindable.calculation = true
		setting.Bindable.BulletSpeed = 12000
		setting.Bindable.AimAssist = true
		setting.Bindable.BulletDrop = 0
		setting.Bindable.ESP = true
		setting.Bindable.Circle =  120
		setting.Bindable.Headshots = 67
		setting.Bindable.UseMouseMove = false
		setting.Bindable.EspUpdateTime = 2
	elseif game.GameId == gameids.madpaintball2 then
		setting.Bindable.AimAssist = true
	elseif game.GameId == 833423526 then -- strucid
		setting.Bindable.AimAssist = true
	end

	

	return setting
end


m.typeofnumber = function(n)
	if n>0 then return 1 elseif n==0 then return 0 else return -1 end
end

m.lft = function(n1, n2)
	--local t1,t2 = m.typeofnumber(n1), m.typeofnumber(n2)
	if math.abs(n1)>math.abs(n2) then
		return n1
	else
		return n2
	end
end

m.LocalCharacter = function()
	return lplr.Character
end
m.IngameSens = function()
	return 1.3
end
m.clonetable = function(t)
	local nt = {}
	for i, v in pairs(t) do
		nt[i]=v
	end
	return nt
end
local randomstrcalltimes = tick()
m.rstr = function(len)
	randomstrcalltimes  = randomstrcalltimes+1
	math.randomseed(randomstrcalltimes)
	len = len or math.random(3, 25)
	local str = ""
	for i=1,len do
		math.randomseed(randomstrcalltimes+i)
		local newchar = string.char(math.random(32, 184))
		str =  str..newchar
	end
	return str
end

m.import = function(toimport)
	if type(toimport) == "number" then
		return game:GetObjects("rbxassetid://" .. toimport)[1]
	else
		if snps then
			return loadstring(syn.request({Url = toimport}).Body)()
		end
		return loadstring(game:HttpGetAsync(toimport))()
	end
end

m.GetGameName = function()
	local gamename = "Default"
	for i, v in pairs(gameids) do
		if v == game.GameId then gamename = i end
	end
	return gamename
end

m.TeamCheck = function(plr)
	if tostring(game.GameId) == tostring(gameids.Unit) then
		if ffc(plr, "TeamC") and plr.TeamC.Value ~= lplr.TeamC.Value then
			return true
		else
			return false
		end
	elseif game.GameId == 633284182 then
		if plr:FindFirstChild("Info") and plr.Info:FindFirstChild("Team") and plr.Info.Team:FindFirstChild("Team") and plr.Info.Team.Team.Value ~= lplr.Info.Team.Team.Value then
			return true
			
		else
			return false
		end
	elseif game.GameId == gameids.Aegis then
		local stats = game:GetService("ReplicatedStorage").PlayerStats:FindFirstChild(plr.Name)
		local lplrstats = game:GetService("ReplicatedStorage").PlayerStats:FindFirstChild(lplr.Name)
		if stats and lplrstats and stats.TeamName.Value ~= lplrstats.TeamName.Value then
			return true
		else
			return false
		end
	elseif game.GameId == gameids.badgay then
		return true
	elseif game.GameId == gameids.Arsenal then
		if #game.Teams:GetChildren()<=1 then
			if plr~=lplr then
				return true
			end
			return false
			
			elseif lplr.Team~= plr.Team then return true
			
		end
	elseif game.GameId == gameids.wfyb then
		if plr == lplr then return false end
		if (plr.Team == nil or lplr.Team == nil) then return true end
		if plr.Team ~= lplr.Team then return true end
	else
		if (plr.Team == nil or plr.Team.Name ~= lplr.Team.Name) and plr ~= lplr then
			return true
		else
			return false
		end
	end
end
m.GetCharacterExistance = function(plr)
	if plr.Character and ffcoc(plr.Character, "Humanoid") and ffcoc(plr.Character, "Humanoid").Health>0 then
		return true
	end
	return false
end
m.GetPlayers = function()
	local plrs  =  {}
	for i, plr in pairs(game:GetService("Players"):GetPlayers()) do
		if m.TeamCheck(plr) and m.GetCharacterExistance(plr) then
			plrs[#plrs+1] = plr
		end
	end
	return plrs
end
m.GetHead = function(plr)
	return ffc(plr.Character, "Head")
end

m.GetTeamColor = function(plr)
	local color = Color3.new(.8, 1, .8)
	if plr.Team then
		color = plr.Team.TeamColor.Color
	end
	return color
end
m.GetCharacters = function()
	local chars = {}
	for  i, plr in pairs(m.GetPlayers()) do
		if m.GetCharacterExistance(plr) and ffc(plr.Character,"Head") then
			chars[#chars+1] = {name = plr.Name, char =plr.Character, teamcolor = m.GetTeamColor(plr)}
		end
	end
	return chars
end
m.GetHealth = function(char, str)
	local hum = ffcoc(char, "Humanoid")
	if hum then 
		if str then return "HP:"..math.floor(hum.Health) else return hum.Health end
	end
end
m.GetTargets = function(headpercentage)
	local targets = {}
	for i, plr in pairs(m.GetPlayers()) do
		if math.random(0, 100)<=headpercentage then
			t = m.GetHead(plr)
		else
			t =ffc(plr.Character, "LowerTorso") or ffc(plr.Character, "Torso")
		end
		if t then
			targets[#targets+1] = t
		end
	end
	return targets
end
m.TriggerDeath = function(head)
	local hum = ffcoc(head.Parent, "Humanoid") or ffc(head.Parent, "Humanoid")
	local ret = false
	if hum then
		spawn(function()
			hum.Died:Wait()
			ret = true
		end)
	end
	spawn(function()
		head:GetPropertyChangedSignal("Parent"):Wait()
		ret = true
	end)
	spawn(function()
		repeat wait(.2) until not workspace:IsAncestorOf(head)
		ret = true
	end)
	repeat wait(.1) until ret == true
	return true
end
m.games = gameids

if game.GameId == gameids.ThoseWhoRemain then
	m.GetCharacters = function()
		return {}
	end
	m.GetTargets = function()
		local t = {}
		for i,v in pairs(workspace.Infected:GetChildren()) do
			pcall(function()
				if v.Head then
					table.insert(t, v.Head)
				end
			end)
			
		end
		return t
	end
	m.IngameSens = function()
		return 0.00525331
	end
elseif game.GameId == gameids.fireteam then
	m.TeamCheck = function(plr)

		if plr.Name == lplr.Name then return false end

		local LT = lplr.Info.Team.Team.Value

		if ffc(plr, 'Info') and ffc(plr.Info, 'Team') then
			return LT ~= plr.Info.Team.Team.Value
		end
		return false
	end
	m.IngameSens = function()
		return 0.0074672926631244
	end
end
if game.GameId == gameids.Phantom_Forces then
	m.GetHealth = function(char, str)
		if str then
			return ""
		else
			return 100
		end
	end
	
	m.GetTargets = function(headpercentage)
		local targets = {}
		local thead = true
		if headpercentage and headpercentage<100 then
			math.randomseed(tick())
			thead = math.random(1, 100)<headpercentage
		end
		
		local team = lplr.Team.Name 
		if team == 'Phantoms' then team = 'Ghosts' else team = 'Phantoms'  end

		for i, plr in pairs(workspace.Players[team]:GetChildren()) do
			local t
			if thead then 
				t = ffc(plr, 'Head')
			else
				t= ffc(plr, 'Torso')
			end
			if t then
				targets[#targets+1] = t
			end
		end
		return targets
	end
	m.GetCharacters = function()
		local chars = {}
		local team = lplr.Team.Name or 'Phantoms'
		if team == 'Phantoms' then team = 'Ghosts' else team = 'Phantoms'  end
		for icount, plr in pairs(workspace.Players[team]:GetChildren()) do
			chars[#chars+1] = {name = ('Enemy #'..tostring(icount) ); char =plr, teamcolor = Color3.new(.8, 1, .8)}
		end
		return chars
	end
	
	m.TriggerDeath = function(head)
		head.Parent:GetPropertyChangedSignal("Parent"):Wait()
		return true
	end	
	m.IngameSens = function()
		return 0.011172804812837
	end
	
elseif game.GameId == gameids.Arsenal then
	m.IngameSens = function()
		return 0.0065442182123661
	end
	m.TriggerDeath = function(head)
		local died = false
		local spp = Vector3.new(-0.3, -396, 1)
		repeat
			local d = head.CFrame.Position - spp; d = d.Magnitude
			if d<20 then died = true return true end
			game:GetService("RunService").RenderStepped:Wait()
		until died == true 
		return true
	end
	
elseif game.GameId == gameids.Apoc2 then
	m.TriggerDeath = function(head)
		repeat wait(.2) until not workspace:IsAncestorOf(head) or head.Transparency == 1 
		return true
	end
	m.GetHealth = function(char, str)
		return ""
	end
    m.getignore = function()
        local ret = {}
        for i, veh in pairs(workspace.Vehicles.Spawned:GetChildren()) do
            for ii, model in pairs(veh:GetChildren()) do
                if model.Name~="Collision" and ( model:IsA("BasePart") or model:IsA("Model") ) then
                    table.insert(ret, model)
                end
            end
        end
        return ret
    end
	m.TeamCheck = function(plr)
		if plr.Name==lplr.Name then
			return false
		end
		--Players.SyntaxHinch.PlayerGui.Interface Main.SquadTag.OuterBox.Maximized.NameLabel
		if ffcoc(lplr, "PlayerGui") and ffc(ffcoc(lplr, "PlayerGui"), "Interface Main") then
			if plr.Character and plr.Character~= nil and ffc(plr.Character, "Head") and plr.Character.Head.Transparency<1 then
				for i, v in pairs(ffcoc(lplr, "PlayerGui")["Interface Main"]:GetChildren() ) do
					if v.Name == "SquadTag" and plr.Character:IsAncestorOf(v.Adornee) then
						return false
					end
				end
				return true
			end
		else
			
			return true
		end
		return false
	end
	m.GetCharacters = function()
		local chars = {}
		for  i, plr in pairs(m.GetPlayers()) do
			if m.GetCharacterExistance(plr) and ffc(plr.Character,"Head") then
				chars[#chars+1] = {name = plr.Name, char =plr.Character, teamcolor = m.GetTeamColor(plr)}
			end
		end
		for i, car in pairs(workspace.Vehicles.Spawned:GetChildren()) do
			if ffc(car, 'Collision') then
				table.insert(chars, {name = car.Name, char = car.Collision, teamcolor = Color3.fromRGB(67, 67, 67)} )
			end
		end
		return chars
	end
	m.IngameSens = function()
		return 0.0034417867660522--0.0042810601885628*1.5
	end
elseif game.GameId == gameids.Jailbreak then
	m.IngameSens = function()
		return 0.0045351416927923
	end
elseif game.GameId == gameids.madpaintball2 then
	m.TeamCheck = function(plr)
		if plr == lplr then return false end
		for i, v in pairs(game:GetService("Workspace").CurrentCamera.VisualContainer.PlayerNameContainer:GetChildren()) do
			if v.Adornee and v.Friendly.Visible == true and plr.Character and plr.Character:IsAncestorOf(v.Adornee) then 
				return false
			end
		end
		return true
	end
	m.IngameSens = function()
		return 0.0033445735131283*1.05
	end
end

if game.GameId == gameids.Attrition then
	m.getignore = function()
		return {workspace.Vehicles}
	end
end

if game.GameId == gameids.BadBuisness then
	
	local getteamed = function()
		local teamed = {}
		for i, v in pairs(lplr.PlayerGui:GetChildren()) do
			if v.Name == "NameGui" and v.Adornee then
				teamed[v.Adornee.Parent.Parent.Name] = true
			end
		end
		return teamed
	end
	m.IngameSens = function()
		return 0.0021189559021573--0.0046487151936
	end
	m.GetCharacters  = function()
		local teamed = getteamed()
		local chars= {}
		for i, char in pairs(workspace.Characters:GetChildren()) do
			local distcheck = false
			
			if not teamed[char.Name] and char.Health.Value>0 and ffc(char, "Hitbox") and ffc(char.Hitbox, "Head") then
				local d = workspace.Camera.CFrame.Position - char.Hitbox.Head.Position; d = d.Magnitude
				if d >5 then
					table.insert(chars, {name = "Enemy "..char.Name, ["char"] = char.Hitbox, teamcolor = Color3.new(.8, 1, .8) })
				end
			end
		end 
		return chars
	end
	m.GetHealth = function(c)
		return "HP:"..math.floor(c.Parent.Health.Value)
	end
	m.GetTargets = function(headp)
		local teamed = getteamed()
		local heads = {}
		for i, char in pairs(workspace.Characters:GetChildren()) do
			
			if not teamed[char.Name] and ffc(char, "Hitbox") and char.Health.Value>0 then
				local dth = workspace.CurrentCamera.CFrame.Position-char.Hitbox:GetModelCFrame().p
				dth = dth.Magnitude
				local add = nil
				if math.random(0, 100)<=headp and ffc(char.Hitbox, "Head") then
					add = char.Hitbox.Head
				else
					add = ffc(char.Hitbox, "Hips")
				end
				if dth>5 then
					table.insert(heads, add)
				end
			end
		end
		return heads
	end
	m.TriggerDeath = function(head)
		local hpv = head.Parent.Parent.Health
		local par = head.Parent.Parent.Parent
		repeat game:GetService("RunService").RenderStepped:Wait() until par ~= head.Parent.Parent.Parent or hpv.Value <= 0
		return true
	end
	m.LocalCharacter = function()
		local mind = 4
		for i, v in pairs(workspace.Characters:GetChildren()) do
			if ffc(v, "Hitbox") and ffc(v.Hitbox, "Head") then
				local d =  workspace.CurrentCamera.CFrame.Position - v.Hitbox.Head.Position
				if d<mind then
					return v
				end
			end
		end
	end
	m.getignore = function()
		local ret = { --[[ffc(workspace, "Arms")]] }
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") then
				table.insert(ret, v)
				--print(v)
			end
		end
		return ret
	end
elseif game.GameId == gameids.ace then
	m.GetCharacters = function()
		local chars = {}
		for  i, plr in pairs(m.GetPlayers()) do
			if m.GetCharacterExistance(plr) and ffc(plr.Character,"Head") and ffc(plr.Character, 'Cosmetics') then
				chars[#chars+1] = {name = plr.Name, char =plr.Character, teamcolor = m.GetTeamColor(plr)}
			end
		end
		return chars
	end
elseif game.GameId == gameids.Attrition then
    m.GetCharacters = function()
        local teammates = {}
        for i, v in ipairs(lplr.PlayerGui:GetChildren()) do
            if v:IsA('BillboardGui') then
                table.insert(teammates, v.Adornee)
            end
        end
        local enemies = {}
        for i, v in ipairs(workspace.Characters:GetChildren()) do
            for ii, vv in ipairs(teammates) do
                if not v:IsAncestorOf(vv) then
                    math.randomseed(os.clock()*100+i+ii)
                    table.insert(enemies, { name = 'enemy'..math.random(-1000000, 1000000), char = ffc(v, 'BodyParts'), teamcolor = Color3.new(0,0,0) })
                end
            end
        end

        return enemies

    end

    m.LocalCharacter = function()
		local mind = 5
		for i, v in pairs(workspace.Characters:GetChildren()) do
            local d =  workspace.CurrentCamera.CFrame.Position - v:GetPivot().Position
            if d<mind then
                return v
            end
		end
	end

end


mainmodule = m
end



local done, er = pcall(function()
	local cut = {ffc = game.FindFirstChild, ffoc = game.FindFirstChildOfClass}
	local lplr = game:GetService("Players").LocalPlayer
	local plrserv = game:GetService("Players")
	local camera = function() return workspace.CurrentCamera or workspace:FindFirstChildOfClass("Camera") end
	local mouse = lplr:GetMouse()
	local centerscreen = function() return camera().ViewportSize/2 end
	local uis = game:GetService("UserInputService")
	--mainmodule = mainmodule()
	local ui       = mainmodule.import(5569916276)
	ui.Main.ZIndex = 1000
	local espui    = mainmodule.import(4660791037)
	local radarui  = mainmodule.import(4679687828) -- 4679687828
	local keycodes = loadstring([[Key = {};

	Key["backspace"] = 8;
	Key["tab"] = 9;
	Key["enter"] = 13;
	Key["shift"] = 16;
	Key["ctrl"] = 17;
	Key["alt"] = 18;
	Key["pause"] = 19;
	Key["caps lock"] = 20
	Key["esc"] = 27;
	Key["spacebar"] = 32;
	Key["page up"] = 33;
	Key["page down"] = 34;
	Key["end"] = 35;
	Key["home"] = 36;
	Key["left arrow"] = 37;
	Key["up arrow"] = 38;
	Key["right arrow"] = 39;
	Key["down arrow"] = 40;
	Key["insert"] = 45;
	Key["delete"] = 46;
	Key["0"] = 48;
	Key["1"] = 49;
	Key["2"] = 50;
	Key["3"] = 51;
	Key["4"] = 52;
	Key["5"] = 53;
	Key["6"] = 54;
	Key["7"] = 55;
	Key["8"] = 56;
	Key["9"] = 57;
	Key["a"] = 65;
	Key["b"] = 66;
	Key["c"] = 67;
	Key["d"] = 68;
	Key["e"] = 69;
	Key["f"] = 70;
	Key["g"] = 71;
	Key["h"] = 72;
	Key["i"] = 73;
	Key["j"] = 74;
	Key["k"] = 75;
	Key["l"] = 76;
	Key["m"] = 77;
	Key["n"] = 78;
	Key["o"] = 79;
	Key["p"] = 80;
	Key["q"] = 81;
	Key["r"] = 82;
	Key["s"] = 83;
	Key["t"] = 84;
	Key["u"] = 85;
	Key["v"] = 86;
	Key["w"] = 87;
	Key["x"] = 88;
	Key["y"] = 89;
	Key["z"] = 90;
	Key["lwindows"] = 91; -- Left Windows Key
	Key["rwindows"] = 92; -- Right Windows Key
	Key["appkey"] = 93; -- Application key - located between the right Windows and Ctrl keys on most keyboards
	-- Numpad numbers start
	Key["1n"] = 97;
	Key["2n"] = 98;
	Key["3n"] = 99;
	Key["4n"] = 100;
	Key["5n"] = 101;
	Key["6n"] = 102;
	Key["7n"] = 103;
	Key["8n"] = 104;
	Key["9n"] = 105;
	Key["*n"] = 106;
	Key["+n"] = 107;
	Key["-n"] = 109;
	Key[".n"] = 110;
	Key["/n"] = 111;
	-- Numpad numbers end
	Key["f1"] = 112;
	Key["f2"] = 113;
	Key["f3"] = 114;
	Key["f4"] = 115;
	Key["f5"] = 116;
	Key["f6"] = 117;
	Key["f7"] = 118;
	Key["f8"] = 119;
	Key["f9"] = 120;
	Key["f10"] = 121;
	Key["f11"] = 122;
	Key["f12"] = 123;
	Key["numlock"] = 144;
	Key["scrolllock"] = 145;
	Key[";"] = 186;
	Key["="] = 187;
	Key[","] = 188;
	Key["-"] = 189;
	Key["."] = 190;
	Key["/"] = 191;
	Key["`"] = 192;
	Key["["] = 219;
	Key["\\"] = 220;
	Key["]" ] = 221;
	Key["'"] = 221;
	return Key]])()
	local autofarm = false; local farm_ui = mainmodule.import(4610581828)
	local ver = 7
	local funcs = {}
	local bindings = nil
	local stats = {}	
	stats.fps = 60
	local ignore = {}
	local setting = mainmodule.getsettings()
	local esp = {}
	esp.Allparts = {}
	local tdtime = tick()-100
	local aimbot = {}
	aimbot.hide = false
	aimbot.working = true
	aimbot.Screendiag = (camera().ViewportSize.X^2+camera().ViewportSize.Y^2)^0.5
	aimbot.Target = nil
	aimbot.realignore = {}
	aimbot.targets = {}
	aimbot.newbox = false
	
	
	local box = false
	local msg = Instance.new("Message", game.CoreGui) msg.Text = "Open roblox settings for aimbot camera sensitivity to set up"
	wait(.1)
	keypress(keycodes.esc)
	repeat
		pcall(function()
			box = game.CoreGui.RobloxGui.SettingsShield.SettingsShield.MenuContainer.PageViewClipper.PageView.PageViewInnerFrame.Page["Camera SensitivityFrame"].Slider.CameraSensitivityTextBox
		end)
		pcall(function()
			if not box then
				box = game.CoreGui.InGameMenu.PageContainer.GameSettings.Page.PageContainer.PageContents.CameraSensitivityMouseSlider.Slider.TextContainer.Box
				if box then
					aimbot.newbox = true
				end
			end
		end)
		wait(.05)
	until box
	msg.Text = "Done"
	wait(.15)
	msg.Parent = nil
	keypress(keycodes.esc)
	
	
	local v3n, v2n = Vector3.new, Vector2.new
	local cfn = CFrame.new
	
	local prehided_settings = nil
	local function hide()
		if aimbot.hide == true then
			local set = true
			ui.Enabled = set
			aimbot.AimCircle.Visible = set
			aimbot.MovementCount.aimat.Visible = set
			aimbot.MovementCount.line.Visible  = set
			setting.Bindable.ESP = prehided_settings.ESP
			aimbot.hide = not set
			setting.Bindable.Radar = prehided_settings.Radar
		else 
			prehided_settings = mainmodule.clonetable(setting.Bindable)
			local set = false
			ui.Enabled = set
			aimbot.AimCircle.Visible = set
			aimbot.MovementCount.aimat.Visible = set
			aimbot.MovementCount.line.Visible  = set
			setting.Bindable.ESP = set
			aimbot.hide = not set
			setting.Bindable.Radar = set
		end
	end
	
	funcs.RoundTo = function(val, to)
		to = to or 100
		if typeof(val) == "number" then
			return math.floor(val*to)/to
		elseif typeof(val) == "Vector3" then
			return Vector3.new(math.floor(val.X*to)/to, math.floor(val.Y*to)/to, math.floor(val.Z*to)/to)
		elseif typeof(val) == "CFrame" then
			local all = {val:GetComponents()}
			for i, v in pairs(all) do
				all[i] = math.floor(v*to)/to
			end
			return CFrame.new(unpack(all))
		end
	end
	funcs.greaterthan = function(n, rt)
		local ab = math.abs(n)
		if ab>rt then
			return n
		else
			return 0
		end	
	end
	aimbot.sens = function()
		local robloxsens = 1.02
		local boxshit = tonumber(box.Text)
		if aimbot.newbox then
			boxshit = boxshit/5
		end
		if uis.MouseBehavior ~= Enum.MouseBehavior.Default then
			robloxsens = boxshit*mainmodule.IngameSens()
		end
		return robloxsens
	end
	aimbot.Recalculate = function()
		msg.Parent = game.CoreGui
msg.Text = [[Go to first person and
DO NOT MOVE THE MOUSE]];
		wait(3)
		msg.Text = "Calculating..."
		wait(.5)
		local cam = camera()
		local mv = 20
		local sens = tonumber(box.Text)

		local or1 =v3n(cam.CFrame:ToOrientation() )
		
		mousemoverel(mv/sens/math.min(70,cam.FieldOfView)*70, 0)
		wait(.3)
		local or2 =v3n(cam.CFrame:ToOrientation() )
		
		local diff = or2-or1
		local degsperpix = math.abs(diff.Y+diff.X)/mv
		setclipboard(tostring(degsperpix))
		
		mainmodule.IngameSens = function()
			return degsperpix
		end
		
		wait(.1)
		msg.Text = "Done"
		wait(1)
		msg.Parent = nil
	end
	aimbot.upsens= function()
		local s1 = mainmodule.IngameSens()
		local nsens = s1*.96
		setclipboard(tostring(nsens))
		mainmodule.IngameSens = function()
			return nsens
		end
	end
	aimbot.downsens= function()
		local s1 = mainmodule.IngameSens()
		local nsens = s1*1.0416666666667
		setclipboard(tostring(nsens))
		mainmodule.IngameSens = function()
			return nsens
		end
	end
	--        ui.Main.Container.ResetSensitivity.MouseButton1Down:Connect(aimbot.Recalculate)
	--   ui.Main.Container.ResetSensitivity.plus.MouseButton1Down:Connect(aimbot.upsens)
	--  ui.Main.Container.ResetSensitivity.minus.MouseButton1Down:Connect(aimbot.downsens)
	aimbot.RobloxSreenOffset = v3n(0, 38, 0)
	aimbot.pointat = function(v3pos)
		local cam = camera()
		if setting.Bindable.UseMouseMove == true then
			if uis.MouseBehavior == Enum.MouseBehavior.LockCenter or uis.MouseBehavior == Enum.MouseBehavior.LockCurrentPosition then
				local despp= aimbot.sens()
				local lcf = CFrame.new(cam.CFrame.p, v3pos)
				local mcf = v3n(cam.CFrame:lerp(lcf, .1):ToOrientation() )
				local unv = mcf-v3n(cam.CFrame:ToOrientation()); unv = unv*10/despp/(cam.FieldOfView/70)
				mousemoverel(-unv.Y, -unv.X)
			elseif uis.MouseBehavior == Enum.MouseBehavior.Default and not uis:IsMouseButtonPressed(1) then
				local vector, onscr = cam:WorldToScreenPoint(v3pos)
				if onscr then 
					
					local dist = (Vector2.new(vector.X, vector.Y) - Vector2.new(mouse.X,mouse.Y)).Magnitude
					local magnitudeX = mouse.X - vector.X
					local magnitudeY = mouse.Y - vector.Y
					mousemoverel(-magnitudeX*0.5,-magnitudeY*0.5)


				end
			end
		else
			cam.CoordinateFrame = CFrame.new(cam.CFrame.Position, v3pos)
		end
		if aimbot.Target then
			local atpos = cam:WorldToScreenPoint(v3pos)+aimbot.RobloxSreenOffset
			aimbot.MovementCount.aimat.Position = v2n(atpos.X, atpos.Y)
			local targetpos = cam:WorldToScreenPoint(aimbot.Target.CFrame.Position)+aimbot.RobloxSreenOffset
			aimbot.MovementCount.line.From = v2n(targetpos.X, targetpos.Y)
			aimbot.MovementCount.line.To = v2n(atpos.X, atpos.Y)
		end
	end
	
	aimbot.aim = function()
		if setting.Bindable.calculation == false then
			aimbot.pointat(aimbot.Target.CFrame.Position)
		else
			local tar = aimbot.Target
			local vel = aimbot.targetvel
			local dist = camera().CFrame.Position - tar.CFrame.Position; dist = dist.Magnitude
			local bulletdrop = v3n(0,dist*setting.Bindable.BulletDrop/50,0)
			local timetotarget = dist/setting.Bindable.BulletSpeed
			local traveled = vel*timetotarget
			local aimat = tar.CFrame.Position + traveled+ bulletdrop
			aimbot.pointat(aimat)
		end
	end
	aimbot.rwalls = {}
	aimbot.RemoveWall = function()
		local t = mouse.Hit.p
		local obj, pos = workspace:FindPartOnRayWithIgnoreList(Ray.new(camera().CFrame.p, (t-camera().CFrame.p)*2 ),ignore )
		if obj then
			local cln = obj:Clone()
			cln:ClearAllChildren()
			cln.Parent = camera()
			cln.CanCollide = false
			cln.Transparency = .75
			obj.CFrame = CFrame.new(0, -100000000, 0)
			obj:GetPropertyChangedSignal("Parent"):Connect(function()
				cln:Destroy()
			end)
		end
	end
	funcs.getfov = function(pos)
		local vec, onscr = camera():WorldToScreenPoint(pos);vec = vec-v3n(mouse.X, mouse.Y);local len = (vec.X^2+vec.Y^2)^0.5
		return len, onscr
	end
	funcs.size = function(obj, sz)
		if sz<=0 then return false end
		local x, y, z = obj.Size.X<sz, obj.Size.Y<sz, obj.Size.Z<sz
		if (x and y) or (x and z) or (y and z) then
			return true
		end
	end
	
	spawn(function()
		local updign = function()
			aimbot.realignore = {}
			for i, v in pairs(ignore) do
				aimbot.realignore[i] = v
			end
			for i, v in pairs(mainmodule.getignore()) do
				table.insert(aimbot.realignore,v)
			end
			for i, v in pairs(aimbot.targets) do
				table.insert(aimbot.realignore,v)
			end
		end
		while wait(1.5) do
			pcall(updign)
		end
	end)
	spawn(function()
		while wait(60*5) do
			ignore = {}
		end
	end)

	funcs.Raycast = function(p0, p1)
		local dif = p1-p0
		local mag= dif.Magnitude
		if mag <setting.Bindable.MaxRaycastDistance+5 then
			local d =math.min(mag, setting.Bindable.MaxRaycastDistance)
			local unit = dif.Unit
			local ray = Ray.new(p0, dif.Unit*d)


			local obj, pos, normal = workspace:FindPartOnRayWithIgnoreList(ray, aimbot.realignore)
			
			if obj and obj~= aimbot.Target and  ( (obj.Transparency >0.15 or obj.CanCollide == false) or funcs.size(obj, setting.PartSize) )  then
				table.insert(ignore, obj)
			end
			return obj, pos, normal
		else
			return nil, p0, v3n()
		end
	end
	
	funcs.TargetPart = function(p)
		aimbot.Target = p
		if p and p~= nil then
			aimbot.LastShowUpTime = tick()
			aimbot.LastTargetPos = p.CFrame.Position
			mainmodule.TriggerDeath(p) 
			if aimbot.Target == p then
				aimbot.Target = nil
				tdtime = tick()
			end
		end
	end
	funcs.ReloadMain = function()
		msg.Text = "Loading started"
		msg.Parent = game.CoreGui
		local newm = game:HttpGetAsync("https://pastebin.com/raw/Tr4U84DV")
		delay(11, function()
			msg.Parent = nil
		end)
		for i = 1, 10, .05 do
			if newm and newm~= nil then
				mainmodule = loadstring(newm)()
				msg.Text = "Loaded new module"
				wait(.75)
				msg.Parent = nil
				break
			end
			wait(.05)
		end
	end
	aimbot.bindedboxes = {}
	funcs.ToggleSwitch = function(sw)
		local st = sw.Status
		if st.ImageTransparency == 0 then
			for i = 0, 1, 0.016*10 do
				st.ImageTransparency = i
				game:GetService("RunService").RenderStepped:Wait()
			end
			st.ImageTransparency = 1
			return false
		elseif st.ImageTransparency == 1 then
			for i = 0, 1, 0.016*10 do
				st.ImageTransparency = 1-i
				game:GetService("RunService").RenderStepped:Wait()
			end
			st.ImageTransparency = 0
			return true
		end
	end
	funcs.BindAction = function(thing)
		local n = thing.Name
		local tb = cut.ffc(thing, "TextBox")
		local sw = cut.ffc(thing, "Switch")
		if tb then
			aimbot.bindedboxes[tb] = false
			tb.FocusLost:Connect(function()
				local num = tonumber(tb.Text)
				if num then
					setting.Bindable[n] = num
				else
					tb.Text = tostring(setting.Bindable[n])
				end
				aimbot.bindedboxes[tb] = false
			end)
			tb.Focused:Connect(function()
				aimbot.bindedboxes[tb] = true
			end)
		else
			sw.MouseButton1Down:Connect(function()
				setting.Bindable[n] = funcs.ToggleSwitch(sw)
			end)
		end
	end
	local uiframes = ui.Main.Container.AllFrames
	funcs.SwitchFrame = function(newname, delta)
		delta = delta or .2
		local slider = ui.Main.Container.FrameNames.Slider
		local nbutton = ui.Main.Container.FrameNames[newname]
		local nframe = uiframes[newname]
		local newsp = UDim2.new(0.01, 50+nbutton.Position.X.Offset, 0.8, 0)
		local newfp = UDim2.new( -(nframe.Position.X.Scale-0.5) ,0,0,0)
		  slider:TweenPosition(newsp, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, delta)
		uiframes:TweenPosition(newfp, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, delta)
		aimbot.CurrentUiFrame = newname
	end
	
	game:GetService("RunService").RenderStepped:Connect(function()
		for box, focused in pairs(aimbot.bindedboxes) do
			if not focused then
				box.Text = tostring(math.floor(setting.Bindable[box.Parent.Name]*1000)*.001 )
			end
		end
	end)
	
	--setting up
	ignore[1] = camera()
	ignore[2] = lplr.Character
	if game.GameId ~= 833423526 then
		ui.Name = mainmodule.rstr()
		ui.Parent =  game:GetService("CoreGui")
		ui.Main.Draggable = true
	end
	--error()
	do
		local sensreset = uiframes.OtherFrame.ResetSensitivity
		sensreset.MouseButton1Down:Connect(aimbot.Recalculate)
		sensreset.plus.MouseButton1Down:Connect(aimbot.upsens)
		sensreset.minus.MouseButton1Down:Connect(aimbot.downsens)
	end
	for i, frame in pairs(uiframes:GetChildren()) do
		for ii, thing in pairs(frame:GetChildren()) do
			if thing:IsA("TextLabel") and (cut.ffc(thing, "Switch") or cut.ffc(thing, "TextBox") ) then
				funcs.BindAction(thing)
			end
		end
	end
	aimbot.CurrentUiFrame = "AimbotFrame"
	for i, framebutton in pairs(ui.Main.Container.FrameNames:GetChildren()) do
		local fn = framebutton.Name
		if framebutton:IsA("TextButton") then
			framebutton.MouseButton1Down:Connect(function()
				if fn~= aimbot.CurrentUiFrame then
					funcs.SwitchFrame(fn)
				end
			end)
		end
	end
	do
		aimbot.AimCircle = Drawing.new("Circle")
		aimbot.AimCircle.Position = v2n(mouse.X, mouse.Y)
		aimbot.AimCircle.Radius = 120
		aimbot.AimCircle.Color = Color3.new(.8, 1, .8)
		aimbot.AimCircle.Filled = false
		aimbot.AimCircle.Thickness = 3
		aimbot.AimCircle.Transparency = .75
		aimbot.AimCircle.NumSides = 256
		aimbot.AimCircle.Visible = true
		
		aimbot.MovementCount = {}
		aimbot.MovementCount.aimat = Drawing.new("Circle")
		aimbot.MovementCount.aimat.Position = v2n(mouse.X, mouse.Y)
		aimbot.MovementCount.aimat.Radius = 6
		aimbot.MovementCount.aimat.Color = Color3.new(.8, 1, .8)
		aimbot.MovementCount.aimat.Filled = false
		aimbot.MovementCount.aimat.Thickness = 2
		aimbot.MovementCount.aimat.Transparency = .5
		aimbot.MovementCount.aimat.NumSides = 32
		aimbot.MovementCount.aimat.Visible = true
		
		aimbot.MovementCount.line= Drawing.new("Line")
		aimbot.MovementCount.line.From = v2n()
		aimbot.MovementCount.line.To = v2n()
		aimbot.MovementCount.line.Transparency = .5
		aimbot.MovementCount.line.Thickness = 2
		aimbot.MovementCount.line.Color =Color3.new(.8, 1, .8)
		aimbot.MovementCount.line.Visible = true
	end
	do
		local hidden = false
		local hb = ui.Main.HideShow
		local startsize = ui.Main.Container.Size
		local switching = false
		local mainsize = ui.Main.Size
		
		hb.MouseButton1Down:Connect(function()
			if hidden == false and not switching then
				switching = true
				ui.Main.Container:TweenSize(UDim2.new(1, 0, 0, 0), Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, .25)
				ui.Main:TweenSize(UDim2.new(0, 216, 0, 16), Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, .25)
				hidden = true
				for i = 1, 180, 15 do
					hb.Rotation = i
					game["Run Service"].RenderStepped:Wait()
				end
				hb.Rotation = 180
				switching  = false
				
			elseif hidden == true and not switching then
				switching = true
				ui.Main.Container:TweenSize(startsize, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, .25)
				ui.Main:TweenSize(mainsize, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, .25)
				hidden = false
				for i = 1, 180, 15 do
					hb.Rotation = 180+i
					game["Run Service"].RenderStepped:Wait()
				end
				hb.Rotation = 0
				switching = false
				
			end
		end)
		
	end
	
	bindings = {
		aim = Enum.KeyCode.E;
		hide =         {Enum.KeyCode.LeftControl, Enum.KeyCode.H, func = hide};
		reloadmodule = {Enum.KeyCode.LeftControl, Enum.KeyCode.M, func = funcs.ReloadMain};
		destroy =      {Enum.KeyCode.LeftControl, Enum.KeyCode.J, func = aimbot.RemoveWall}
	}
	
	aimbot.LastEClick = 0
	uis.InputBegan:Connect(function(inp, gg)
		if true then
			if inp.UserInputType == Enum.UserInputType.Keyboard then
				local kk = inp.KeyCode
				if kk == bindings.aim and aimbot.working then
					aimbot.LastEClick = tick()
					if not aimbot.Target then
						local targets = mainmodule.GetTargets(setting.Bindable.Headshots)
						local lowest = aimbot.AimCircle.Radius
						local targ =  nil
						aimbot.targets = targets
						for i, v in pairs(targets) do
							local len, onscr = funcs.getfov(v.CFrame.Position)
							if onscr and len <lowest  then targ = v lowest  = len end
						end
						funcs.TargetPart(targ)
					else
						aimbot.Target = nil
						tdtime = tick()
					end
					
				end
				
				for i, v in pairs(bindings) do
					if typeof(v) == "table" then
						if kk == v[2] and uis:IsKeyDown(v[1]) then
							v.func()
						end
					end
				end
				
			end
		end
	end)
	
	funcs.Click = function(dt)
		if d then
			mouse1press()
			wait(dt)
			mouse1release()
		else
			mouse1press()
			mouse1release()
		end
	
	end
	funcs.ClearEsp = function(espdata)
		for i, v in pairs(espdata.bhas) do
			v:Destroy()
		end
		espdata.ui:Destroy()
	end
	funcs.SetEspColor = function(espdata, color)
		for i, v in pairs(espdata.bhas) do
			v.Color3 = color
		end
		espdata.ui.Main.ImageColor3 = color
	end
	aimbot.LastTargetPos = v3n()
	aimbot.LastShowUpTime = 0
	aimbot.targetvel = Vector3.new(0,0,0)
	local mincirc = aimbot.Screendiag/400
	game:GetService("RunService"):BindToRenderStep(mainmodule.rstr, Enum.RenderPriority.Last.Value-1, function(dt)
		stats.fps = 1/(dt or 0.01666)
		aimbot.AimCircle.Radius =setting.Bindable.Circle+math.clamp(math.cos(tick()*5), -mincirc, mincirc)
		ignore[2] = lplr.Character
		ignore[1] = camera()
		aimbot.MovementCount.aimat.Position = v2n(10000000,10000000)
		aimbot.MovementCount.line.From = v2n(10000000, 1000000);aimbot.MovementCount.line.To = v2n(10000000, 1000000)
		
		if setting.Bindable.SmartCircle == true then
			aimbot.AimCircle.Radius = aimbot.AimCircle.Radius*math.clamp(70/camera().FieldOfView, .9, 2.5)
		end

		if aimbot and aimbot.working == true then
			
			if aimbot.Target then
				local dif, d = aimbot.Target.CFrame.Position - aimbot.LastTargetPos, nil;d = dif.Magnitude
				aimbot.LastTargetPos = aimbot.Target.CFrame.Position
				if game.GameId == mainmodule.games.Arsenal and d>30 then 
					aimbot.Target = nil
					tdtime = tick()
				end
				if aimbot.Target then
					if aimbot.Target.Velocity.Magnitude <2 or true then
						local tv = dif/dt
						aimbot.targetvel = tv*math.min(30/tv.Magnitude,1 )
					else
						aimbot.targetvel = aimbot.Target.Velocity
					end
				end
			end
			
			aimbot.AimCircle.Position = v2n(mouse.X, mouse.Y+38)
			if setting.Bindable.AimAssist == true then
				if not aimbot.Target and tick()-aimbot.LastEClick>.3 then -- aimassist
					local lowest,tar = aimbot.AimCircle.Radius, nil
					local trs = mainmodule.GetTargets(setting.Bindable.Headshots)
					aimbot.targets = trs
					for i, head in pairs(trs) do
						local fov, onscr = funcs.getfov(head.CFrame.Position)
						if (onscr and fov<lowest) then
							local obj, pos = funcs.Raycast(camera().CFrame.Position+camera().CFrame.lookVector*1.5, head.CFrame.Position)
							if (obj == head or (pos -head.CFrame.Position).Magnitude<3) then
								tar = head
							end
						end
					end
					funcs.TargetPart(tar)
				elseif aimbot.Target then
					local head = aimbot.Target
					local obj, pos = funcs.Raycast(camera().CFrame.Position+camera().CFrame.lookVector*1.5, head.CFrame.Position)
					if obj ~= head and (pos -head.CFrame.Position).Magnitude>3 then
						if tick()- aimbot.LastShowUpTime>.15 then
							aimbot.Target = nil
							tdtime = tick()
						end
					else
						aimbot.LastShowUpTime = tick()
					end
				end
			end
			if aimbot.Target then
				if not workspace:IsAncestorOf(aimbot.Target) then
					aimbot.Target = nil
					tdtime = tick()
				end
			end
			if uis:IsKeyDown(Enum.KeyCode.RightBracket) then
				setting.Bindable.BulletDrop = setting.Bindable.BulletDrop+dt/2.9
			elseif uis:IsKeyDown(Enum.KeyCode.LeftBracket) then
				setting.Bindable.BulletDrop = math.max(0,setting.Bindable.BulletDrop-dt/2.1)
			end
				
			if aimbot.Target then
				aimbot.aim()
			end
		else
			aimbot.AimCircle.Position = v2n(10000, 100000)
		end
		
	end)
	
	do -- radar		
		local rui = radarui
		rui.Parent = game.CoreGui
		local arrow = rui.Arrow:Clone()
		rui.Arrow.Parent = nil
		local rfr = rui.RadarFrame
		rfr.Draggable = true
		rfr.Active = true
		local cam = workspace.CurrentCamera
		local radimg = rui.RadarFrame.RadarImage
		local localarrow  = arrow:Clone()
		localarrow.Position = UDim2.new(.5, 0, .5, 0)
		localarrow.Rotation = 0
		localarrow.Size = UDim2.new(0, 17, 0, 17)
		localarrow.Parent = rfr
		
		local tracked = {}
		
		spawn(function()
			while wait(1) do
				if setting.Bindable.Radar then
					for i, v in pairs(mainmodule.GetCharacters()) do
						local nindex = v.char
						if not tracked[nindex] then
							local ar = arrow:Clone()
							ar.Parent = rfr
							ar.ImageColor3 = v.teamcolor
							tracked[nindex] = ar
							spawn(function()
								mainmodule.TriggerDeath(v.char.Head)
								ar:Destroy()
								tracked[nindex] = nil
							end)
						end
					end
				end
			end
		end)
		
		local scale = setting.Bindable.RadarSize
		game:GetService("RunService"):BindToRenderStep("Radar", Enum.RenderPriority.Last.Value, function()
			if setting.Bindable.Radar == true then
				scale = setting.Bindable.RadarSize*2.2
				rui.Enabled = true
				local camrot = v3n(cam.CFrame:ToOrientation())
				rfr.Rotation = math.deg(camrot.Y)
				localarrow.Rotation= -rfr.Rotation-90
				radimg.Rotation = -rfr.Rotation
				for mod, fr in pairs(tracked) do
					if workspace:IsAncestorOf(mod) then
						local diff =mod:GetModelCFrame().Position-cam.CFrame.Position
						if mod.PrimaryPart then
							local orot = v3n(mod.PrimaryPart.CFrame:ToOrientation())
							local ydiff = orot.Y
							fr.Rotation = -math.deg(ydiff)-90
						end
						local fx = rfr.Size.X.Offset
						fr.Position = UDim2.new(0.5+diff.X/scale, 0, 0.5+diff.Z/scale, 0)
						local dist = v2n(math.abs(fr.Position.X.Scale-.5),math.abs( fr.Position.Y.Scale-.5)).Magnitude
						fr.ImageTransparency = (dist-0.35)/0.08+0.1
					else
						fr.Parent = nil
						tracked[mod] = nil
					end
				end
			else
				rui.Enabled = false
				for mod, fr in pairs(tracked) do
					fr.Parent = nil
					tracked[mod] = nil
				end
			end
		end)
	end
	
	spawn(function()
		while wait(60*2) do
			pcall(function()
				for i, v in pairs(ignore) do
					if not workspace:IsAncestorOf(v) then
						ignore[i] = nil
					end
					wait(.07)
				end
			end)
		end
	end)
	local uidistances = {}
	funcs.UpdateHeadUi = function(ui, data)
		local char = ui.Adornee
		local delta = tick()-data.lastupdate
		local chp 
		if char:IsA('Model') then
			chp= char:GetModelCFrame().Position
		else
			chp = char.Position
			char = char.Parent
		end
		
		local d =  camera().CFrame.Position - chp; d=d.Magnitude

		if d<200 then
			table.insert(uidistances, d)
		end

		local vel = ""
		if setting.Bindable.ShowVelocity == true then
			vel = " Vel:"..math.min(999,math.floor((chp-data.lastpos).Magnitude/delta) )
		end
		ui.Main.InfoT.Text = mainmodule.GetHealth(char, true).." D:"..math.floor(d)..vel
		ui.StudsOffset = Vector3.new(0, math.max(d*200/1500, 4) ,0 )
		data.lastpos = char:GetModelCFrame().Position
		data.lastupdate = tick()
	end
	
	local gayb =  game.GameId == mainmodule.games.badgay
	spawn(function()
		
		local lt = tick()
		while wait(setting.Bindable.EspUpdateTime) do
			pcall(function()
			uidistances = {}
			epsdt = tick()-lt
			lt = tick()
			local status, error = pcall(function()
				if setting.Bindable.ESP == true then
					for i, charinfo in pairs(mainmodule.GetCharacters()) do
						local name = charinfo.name
						local char = charinfo.char
						if esp.Allparts[char] == nil or esp.Allparts[char] and not esp.Allparts[char].lockedto then
							
							if esp.Allparts[char] and not esp.Allparts[char].lockedto then
								funcs.ClearEsp(esp.Allparts[char])
							end
							
							
							local color=charinfo.teamcolor
							
							local espdata = {bhas = {}, lockedto = char, ui = espui:Clone()}
							esp.Allparts[char] = espdata
							pcall(function()
								espdata.ui.Parent = game.CoreGui
								espdata.ui.Main.NameT.Text = name
								espdata.ui.Adornee = cut.ffc(char, 'Head') or char
								espdata.lastpos = char:GetModelCFrame().Position
								espdata.lastupdate = tick()
							end)
							pcall(function()
								funcs.UpdateHeadUi(espdata.ui, espdata)
							end)
							
							
							for i, v in pairs(char:GetDescendants()) do
								if v:IsA("BasePart") and (v.Transparency<1 or gayb) then
									local bha = Instance.new("BoxHandleAdornment", game.CoreGui)
									bha.Adornee = v
									bha.Size = v.Size
									bha.Transparency = .8
									bha.AlwaysOnTop = true
									bha.ZIndex = 2
									bha.Visible = true
									delay(.1, function()
										bha.ZIndex = 100
									end)
									table.insert(espdata.bhas, bha)
								end
							end
							funcs.SetEspColor(espdata, color)
							esp.Allparts[char] = espdata
							spawn(function()
								local dead = mainmodule.TriggerDeath(char.Head)
								funcs.ClearEsp(espdata)
								esp.Allparts[char] = nil
							end)
						else
							funcs.SetEspColor(esp.Allparts[char], charinfo.teamcolor)
						end
					end
					
					for i, v in pairs(esp.Allparts) do
						if not v.lockedto then
							funcs.ClearEsp(v)
							esp.Allparts[i] = nil
						else
							pcall(function()
							funcs.UpdateHeadUi(v.ui, v)
							end)
						end
					end

					
					if #uidistances>1 then
						ui.Enemy.Visible = true
						ui.Enemy.Text = 'Enemy '..math.floor( math.min( unpack( uidistances) )  )..' studs away!'
					else
						ui.Enemy.Visible = false
					end

				else
					for i, v in pairs(esp.Allparts) do
						funcs.ClearEsp(v)
					end
					esp.Allparts = {}
				end
			end)
			if error then warn (error) end

		end)
		end
	end)

	spawn(function()
		while wait(600) do
			if setting.Bindable.ESP == true then
				setting.Bindable.ESP = false
				wait(setting.Bindable.EspUpdateTime*1.05)
				setting.Bindable.ESP = true
			end
		end
	end)
	
	--autoclickloop
	
	local clickfunc = function()
		if aimbot.Target ~= nil and setting.Bindable.AutoShoot == true then
			mouse2press()
			funcs.Click(0)
		elseif setting.Bindable.AutoShoot == true and tick()-tdtime<.3 then
			mouse2release()
		end
	end
	spawn(function()
		while true do
			clickfunc()
			wait(0.02)
		end
	end)
end)
print(er)