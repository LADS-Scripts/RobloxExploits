local lplr = game:GetService('Players').LocalPlayer
local mouse = lplr:GetMouse()
local _remote = game:GetService("ReplicatedStorage").Shared.Remotes.PlaceStructure
local done = false
local buildDelay
local randomness = 0.7
local spread

local numlerp = function(a,b,c)
    return a+(b-a)*c
end

local math = setmetatable({
        random = function(a,b)
            return math.random(a, numlerp(b, a, randomness))
        end
}, {
    __index = function(self, i) 
        return rawget(self, i) or math[i]
    end
})

local skipQueue = {'Pipe', 'T-Junction'}


local remote = {}
remote.queue = {}
remote.FireServer = function(self, ...)
    local args = {...}
    local name = args[1]
    if table.find(skipQueue, name) then
        table.insert(remote.queue, 1, args)
    else
        table.insert(remote.queue, args)
    end
end


local remoteTimeout = os.clock()+1000
task.spawn(function()
    while os.clock()<remoteTimeout do
        if not remote.queue[1] then task.wait() continue end
        local waitTime = buildDelay
        _remote:FireServer(table.unpack(remote.queue[1]))
        table.remove(remote.queue, 1)
        task.wait(waitTime)
    end
end)

task.spawn(function()
    task.wait(180)
    done = true
end)

local rpars = RaycastParams.new()
rpars.FilterType = Enum.RaycastFilterType.Exclude

local raycast = function(pos, dir)
    local ignore = {lplr.Character, workspace.Effects}
    local result
    repeat
        rpars.FilterDescendantsInstances = ignore
        result = workspace:Raycast(pos, dir, rpars)
        if result and result.Instance.CanCollide == false then
            table.insert(ignore, result.Instance)
        end
    until not result or result.Instance.CanCollide == true
    return result
end


mouse.Button1Down:Wait()
local result = raycast(workspace.CurrentCamera.CFrame.Position, mouse.UnitRay.Direction*500)
if not result then return end

local base = result.Instance
local startPos = result.Position
local dir = result.Normal
local up = Vector3.new(0,1,0)
local right = dir:Cross(up)

local cf = CFrame.fromMatrix(startPos, -right, dir, -up)

local middlePlaced = 0

local fourWays = {}
local leftSubs = {}
local rightSubs = {}

local detectPlacement = function(cf, name, threshold)
    threshold = threshold or 1
    local et = os.clock()+40
    local found = false
    local con con = workspace.Structures.ChildAdded:Connect(function(child)
        if child.Name ~= name then return end
        local et2 = os.clock()+10
        repeat task.wait() until child.PrimaryPart or os.clock()>et2
        local dist = (cf.Position-child.PrimaryPart.Position).Magnitude
        if dist>threshold then return end
        
        found = child
        con:Disconnect()
    end)

    repeat task.wait() until found or os.clock()>et
    if con then
        con:Disconnect()
    end
    return found
end

local findDescendant = function(part, name)
    for i, v in next, part:GetDescendants() do
        if v.Name == name then
            return v
        end
    end
end


local placeLeft = function(i)
    if i~= 0 then
        repeat task.wait() until leftSubs[i-1]
    end

    local tcf = cf+dir*.53+dir*i*2.4 +right*math.random(4800, 7000)/1000*spread -up*math.random(1500, 3000)/900
    remote:FireServer(
        'Submersible',
        {
            BasePart = base;
            CFrame = base.CFrame:ToObjectSpace(tcf);
        }
    )
    local sub = detectPlacement(tcf, 'Submersible')
    leftSubs[i] = sub
    local to = os.clock()+20
    i+=1
    repeat task.wait() until fourWays[i] or os.clock()>to
    task.wait(.3)
    remote:FireServer(
        'Pipe',
        {
            {
                SnapPart = sub.PipeFemale:WaitForChild('FemaleFlange');
                CFrame = sub.PipeFemale.FemaleFlange.CFrame
            };
            {
                SnapPart = fourWays[i]:WaitForChild('FemaleFlange1');
                CFrame = fourWays[i].FemaleFlange1.CFrame
            };
        }
    )
end

local placeRight = function(i)
    if i~= 0 then
        repeat task.wait() until rightSubs[i-1]
    end
    local tcf = cf+dir*.53+dir*i*2.4 -right*math.random(4800, 7000)/1000*spread-up*math.random(1500, 3000)/900
    remote:FireServer(
        'Submersible',
        {
            BasePart = base;
            CFrame = base.CFrame:ToObjectSpace(tcf);
        }
    )
    local sub = detectPlacement(tcf, 'Submersible')
    rightSubs[i] = sub
    local to = os.clock()+20
    i+=1
    repeat task.wait() until fourWays[i] or os.clock()>to
    
    remote:FireServer(
        'Pipe',
        {
            {
                SnapPart = sub.PipeFemale:WaitForChild('FemaleFlange');
                CFrame = sub.PipeFemale.FemaleFlange.CFrame
            };
            {
                SnapPart = fourWays[i]:WaitForChild('FemaleFlange3');
                CFrame = fourWays[i].FemaleFlange3.CFrame
            };
        }
    )
end

local tjunks = {}

local placeMiddle = function()
    local tcf = cf+dir*.53+dir*middlePlaced*2.4+up*math.random(-1000, 9000)/7000+right*math.random(-300, 300)/1000
    remote:FireServer(
        'Submersible',
        {
            BasePart = base;
            CFrame = base.CFrame:ToObjectSpace(tcf);
        }
    )
    task.delay(.1, placeLeft, middlePlaced)
    task.delay(.1, placeRight, middlePlaced)
    middlePlaced+=1
    
    
    local sub = detectPlacement(tcf, 'Submersible')
    if not sub then return 'failed' end
    task.spawn(function()
        --FemaleFlange
        local middlePlaced = middlePlaced
        local flange = sub:WaitForChild('PipeFemale'):WaitForChild('FemaleFlange')
        local tcf = CFrame.new(-0.8, -2.1, 0) * CFrame.fromEulerAnglesYXZ(1.570796251296997, 0, -1.5707963705062866)
        remote:FireServer(
            'Four-Way',
            {
                BasePart = flange;
                CFrame = tcf;
            },
            'FemaleFlange4',
            flange
        )

        local fway = detectPlacement(flange.CFrame*tcf,'Four-Way', 4)
        fourWays[middlePlaced] = fway

        fway:WaitForChild('FemaleFlange2')

        local flange = fway.FemaleFlange2
        local tcf = CFrame.new(0, -1.4, 0.8) * CFrame.Angles(-1.5707963705062866, 1.5707963705062866, 0)
        remote:FireServer(
            "T-Junction",
            {
                BasePart = flange;
                CFrame = tcf;
            },
            "FemaleFlange2",
            flange
        )
        local tj = detectPlacement(flange.CFrame*tcf,'T-Junction', 2)
        tjunks[middlePlaced] = tj
        if middlePlaced>1 then
            local startCount = middlePlaced
            task.spawn(function()
                local asfa = os.clock()+20
                repeat task.wait() until tjunks[startCount-1] or os.clock()>asfa
                local flangeName = startCount%2==1 and 'FemaleFlange1' or 'FemaleFlange3'
                local flange0 = findDescendant(tjunks[startCount-1], flangeName)
                local flange1 = findDescendant(tj, flangeName)

                remote:FireServer(
                    'Pipe',
                    {
                        {
                            SnapPart = flange0;
                            CFrame = flange0.CFrame
                        };
                        {
                            SnapPart = flange1;
                            CFrame = flange1.CFrame
                        }
                    }
                )
            end)
        end
    end)
end


buildDelay = 0.5
randomness = 0.7
spread = 0.88

for i = 1, 10 do
    if placeMiddle() == 'failed' then break end
    task.wait(.05)
end



done = true