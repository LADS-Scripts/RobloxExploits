local ffc, ffcoc, wfc = game.FindFirstChild, game.FindFirstChildOfClass, game.WaitForChild
local lplr = game:GetService('Players').LocalPlayer
local mouse = lplr:GetMouse()
local _remote = game:GetService("ReplicatedStorage").Shared.Remotes.PlaceStructure
local done = false
local buildDelay
local randomness = 0.7
local remoteTimeout
local buildTime
local spread
local amount

local numlerp = function(a,b,c)
    return a+(b-a)*c
end

local math = setmetatable({
        random = function(a,b)
            return math.random(a, numlerp(b, a, randomness))
        end
}, {
    __index = function(self, i) 
        return rawget(self, i) or math[i]
    end
})

local skipQueue = {'Pipe', 'T-Junction'}


local remote = {}
remote.fired = {}
remote.queue = {}
remote.FireServer = function(self, ...)
    local args = {...}
    local name = args[1]
    local index = #remote.fired+1
    remote.fired[index] = false
    local data = {args, index}
    if table.find(skipQueue, name) then
        table.insert(remote.queue, 1, data)
    else
        table.insert(remote.queue, data)
    end
    repeat task.wait() until remote.fired[index] or os.clock()>remoteTimeout
end

function CharacterCheck(plr)
	if plr == nil then
		return false
	end
	local char = plr.Character
	if char and ffc(char, 'Humanoid') and ffc(char, 'UpperTorso') and ffc(char, 'Head') and char.Humanoid.Health>0 and ffc(char, 'HumanoidRootPart') then
		return char
	end
end



task.spawn(function()
    repeat task.wait() until remoteTimeout
    while os.clock()<remoteTimeout do
        local info = remote.queue[1]
        if not info then task.wait() continue end
        local args = info[1]
        if not args or not CharacterCheck(lplr) then
            local left = remoteTimeout-os.clock()
            remoteTimeout = os.clock()+left
            task.wait()
            continue
        end

        local base = args[2].BasePart or args[2].SnapPart
        local tpos
        if base then
            if args[2].CFrame.Position.Magnitude<100 then
                tpos = (base.CFrame*args[2].CFrame).Position
            else
                tpos = args[2].CFrame.Positon
            end
        else
            tpos = (args[2][1].CFrame.Position+args[2][2].CFrame.Position)/2
        end
        local humrootpos = lplr.Character.HumanoidRootPart.Position
        
        if (tpos-humrootpos).Magnitude > 90 then
            local left = remoteTimeout-os.clock()
            remoteTimeout = os.clock()+left
            task.wait(.1)
            continue
        end

        remote.fired[info[2]] = true
        _remote:FireServer(table.unpack(args))
        table.remove(remote.queue, 1)
        task.wait(buildDelay)
    end
end)


local rpars = RaycastParams.new()
rpars.FilterType = Enum.RaycastFilterType.Exclude

local raycast = function(pos, dir)
    local ignore = {lplr.Character, workspace.Effects}
    local result
    repeat
        rpars.FilterDescendantsInstances = ignore
        result = workspace:Raycast(pos, dir, rpars)
        if result and result.Instance.CanCollide == false then
            table.insert(ignore, result.Instance)
        end
    until not result or result.Instance.CanCollide == true
    return result
end


mouse.Button1Down:Wait()
local result = raycast(workspace.CurrentCamera.CFrame.Position, mouse.UnitRay.Direction*500)
if not result then return end

local base = result.Instance
local startPos = result.Position
local dir = result.Normal
local up = Vector3.new(0,1,0)
local right = dir:Cross(up)

local cf = CFrame.fromMatrix(startPos, -right, dir, -up)

local middlePlaced = 0

local fourWays = {}
local leftSubs = {}
local rightSubs = {}

local detectPlacement = function(cf, name, threshold)
    threshold = threshold or 1
    local et = os.clock()+140
    local found = false
    local con con = workspace.Structures.ChildAdded:Connect(function(child)
        if child.Name ~= name then return end
        local et2 = os.clock()+10
        repeat task.wait() until child.PrimaryPart or os.clock()>et2
        local dist = (cf.Position-child.PrimaryPart.Position).Magnitude
        if dist>threshold then return end
        
        found = child
        con:Disconnect()
    end)

    repeat task.wait() until found or os.clock()>et
    if con then
        con:Disconnect()
    end
    return found
end

local findDescendant = function(part, name)
    for i, v in next, part:GetDescendants() do
        if v.Name == name then
            return v
        end
    end
end


local placeLeft = function(i)
    if i~= 0 then
        repeat task.wait() until leftSubs[i-1]
    end
    while i-middlePlaced > 3 or i-#rightSubs >2 do
        task.wait()
    end

    local tcf = cf+dir*.53+dir*i*2.4 +right*math.random(4800, 7000)/1000*spread -up*math.random(1500, 3000)/900
    remote:FireServer(
        'Submersible',
        {
            BasePart = base;
            CFrame = base.CFrame:ToObjectSpace(tcf);
        }
    )
    local sub = detectPlacement(tcf, 'Submersible')
    leftSubs[i] = sub
    local to = os.clock()+20
    i+=1
    repeat task.wait() until fourWays[i] or os.clock()>to
    remote:FireServer(
        'Pipe',
        {
            {
                SnapPart = sub.PipeFemale:WaitForChild('FemaleFlange');
                CFrame = sub.PipeFemale.FemaleFlange.CFrame
            };
            {
                SnapPart = fourWays[i]:WaitForChild('FemaleFlange1');
                CFrame = fourWays[i].FemaleFlange1.CFrame
            };
        }
    )
end

local placeRight = function(i)
    if i~= 0 then
        repeat task.wait() until rightSubs[i-1]
    end
    while i-middlePlaced > 3 or i-#leftSubs >2 do
        task.wait()
    end

    local tcf = cf+dir*.53+dir*i*2.4 -right*math.random(4800, 7000)/1000*spread-up*math.random(1500, 3000)/900
    remote:FireServer(
        'Submersible',
        {
            BasePart = base;
            CFrame = base.CFrame:ToObjectSpace(tcf);
        }
    )
    local sub = detectPlacement(tcf, 'Submersible')
    rightSubs[i] = sub
    local to = os.clock()+20
    i+=1
    repeat task.wait() until fourWays[i] or os.clock()>to
    
    remote:FireServer(
        'Pipe',
        {
            {
                SnapPart = sub.PipeFemale:WaitForChild('FemaleFlange');
                CFrame = sub.PipeFemale.FemaleFlange.CFrame
            };
            {
                SnapPart = fourWays[i]:WaitForChild('FemaleFlange3');
                CFrame = fourWays[i].FemaleFlange3.CFrame
            };
        }
    )
end

local tjunks = {}

local placeMiddle = function()

    while middlePlaced-#leftSubs >2 or middlePlaced-#rightSubs >2 do
        task.wait()
    end

    local tcf = cf+dir*.53+dir*middlePlaced*2.4+up*math.random(-1000, 9000)/7000+right*math.random(-300, 300)/1000
    remote:FireServer(
        'Submersible',
        {
            BasePart = base;
            CFrame = base.CFrame:ToObjectSpace(tcf);
        }
    )
    -- task.delay(.1, placeLeft, middlePlaced)
    -- task.delay(.1, placeRight, middlePlaced)
    middlePlaced+=1
    
    
    local sub = detectPlacement(tcf, 'Submersible')
    if not sub then return 'failed' end
    task.spawn(function()
        --FemaleFlange
        local middlePlaced = middlePlaced
        local flange = sub:WaitForChild('PipeFemale'):WaitForChild('FemaleFlange')
        local tcf = CFrame.new(-0.8, -2.1, 0) * CFrame.fromEulerAnglesYXZ(1.570796251296997, 0, -1.5707963705062866)
        remote:FireServer(
            'Four-Way',
            {
                BasePart = flange;
                CFrame = tcf;
            },
            'FemaleFlange4',
            flange
        )

        local fway = detectPlacement(flange.CFrame*tcf,'Four-Way', 4)
        fourWays[middlePlaced] = fway

        fway:WaitForChild('FemaleFlange2')

        local flange = fway.FemaleFlange2
        local tcf = CFrame.new(0, -1.4, 0.8) * CFrame.Angles(-1.5707963705062866, 1.5707963705062866, 0)
        local topPlaceName = middlePlaced == 1 and 'Four-Way' or "T-Junction"
        remote:FireServer(
            topPlaceName,
            {
                BasePart = flange;
                CFrame = tcf;
            },
            middlePlaced == 1 and 'FemaleFlange3' or"FemaleFlange2",
            flange
        )
        local tj = detectPlacement(flange.CFrame*tcf, topPlaceName, 2)
        tjunks[middlePlaced] = tj
        if middlePlaced>1 then
            local startCount = middlePlaced
            task.spawn(function()
                local asfa = os.clock()+40
                repeat task.wait() until tjunks[startCount-1] or os.clock()>asfa
                local flangeName = startCount%2==1 and 'FemaleFlange1' or 'FemaleFlange3'
                local flange0 = findDescendant(tjunks[startCount-1], middlePlaced == 2 and 'FemaleFlange4' or flangeName)
                local flange1 = findDescendant(tj, flangeName)

                while not flange1 do
                    flange1 = findDescendant(tj, flangeName)
                    task.wait()
                end

                remote:FireServer(
                    'Pipe',
                    {
                        {
                            SnapPart = flange0;
                            CFrame = flange0.CFrame
                        };
                        {
                            SnapPart = flange1;
                            CFrame = flange1.CFrame
                        }
                    }
                )
            end)
        end
    end)
end

task.delay(.1, function()
    for i = 1, amount do
        placeRight(i-1)
    end
end)
task.delay(.1, function()
    for i = 1, amount do
        placeLeft(i-1)
    end
end)
task.delay(.06, function()
    for i = 1, amount do
        if placeMiddle() == 'failed' then break end
    end
end)

buildDelay = 0.4
randomness = 0.7
spread = 0.88
buildTime = 600
amount = 2

remoteTimeout = os.clock()+buildTime