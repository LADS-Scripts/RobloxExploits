
_G.saveRadius = 400

local lplr = game.Players.LocalPlayer
local mouse = lplr:GetMouse()
local repst = game.ReplicatedStorage
local remote = repst.Shared.Remotes.PlaceStructure
local uis = game:GetService('UserInputService')
local structures = workspace:WaitForChild('Structures')
local run = game:GetService('RunService')
local recording = true
local wait = function(i)
	for _ = 1, i or 1 do
		run.RenderStepped:Wait()
	end
end

local searching = false
function replace(str, find, replace)
    local parts = {}
    local pos = 1

    while true do
        local start, stop = string.find(str, find, pos, true)
        if not start then
            break
        end

        table.insert(parts, string.sub(str, pos, start - 1))
        table.insert(parts, replace)

        pos = stop + 1
    end

    table.insert(parts, string.sub(str, pos))

    return table.concat(parts)
end


function stringReplace(str, find, replace)
    local parts = {}
    local pos = 1

    while true do
        local start, stop = string.find(str, find, pos, true)
        if not start then
            break
        end

        table.insert(parts, string.sub(str, pos, start - 1))
        table.insert(parts, replace)

        pos = stop + 1
    end

    table.insert(parts, string.sub(str, pos))

    return table.concat(parts)
end



local tpairs = function(str, inverted)
	local tbl = {}
	for i = inverted and #str or 1, inverted and 1 or #str, inverted and -1 or 1 do
		tbl[#tbl+1] = str:sub(i,i)
	end
	return ipairs(tbl)
end

local tostring2 = function(number, afterDot)
	if typeof(number) ~= 'number' then return tostring(number) end
	return string.format('%.4f', number)
end

local round = function(n, s)
	return math.round(n/s)*s
end

local prounding = 0.001
local rrounding = 0.001

local cfToString = function(cf)
	local o = {cf:ToEulerAnglesYXZ()}
	return tostring2 (round(cf.X, prounding) )..','..tostring2 (round(cf.Y, prounding))..','..tostring2 (round(cf.Z, prounding))..','..tostring2 (round(o[1], rrounding))..','..tostring2 (round(o[2], rrounding))..','..tostring2 (round(o[3], rrounding))
end

local cfToString2 = function(cf)
	return 'cf('..cfToString(cf)..')'
end

mouse.Button1Down:Wait()
local base = mouse.Target
local _history={}
_history[0] = {part = base, recorded={}, names = {}, attachPoints = {}, placed = {} }

function deepcopy(tbl)
	if tbl == nil then return nil end
	local new = {}
	
	for i, v in pairs(tbl) do
		if typeof(v) == 'table' then
			new[i] = deepcopy(v)
		else
			new[i] = v
		end
	end
	return new
end

local setHistoryStep = function(found)
	local newIndex = #_history+1
	local prev = _history[ #_history ]
	local new = {part = found}
	for i, v in ipairs({'recorded', 'names', 'attachPoints', 'placed'}) do
		new[v] = deepcopy( prev[v] )
	end
	_history[newIndex] = new
end

local undo = function()
	local m = history.part
	table.remove(_history, #_history)
	getRecorded()
	print('reverted to', #_history, 'deleted',(m and m.Name or '') )
	
	if m then
		for i, v in ipairs(m:GetDescendants()) do
			if v:IsA('BasePart') and v.Transparency<1 then
				v.Transparency = .5
				v.Color = v.Color:Lerp( Color3.new(0, 1, 0), .3)
				v.Material = Enum.Material.Neon
			elseif v:IsA('Decal') then
				v.Transparency = 1
			end
		end
	end	
end

history = setmetatable({}, {
	__index = function(self, i)
		return _history[#_history][i]
	end,
	__newindex = function(self, i,v)
		_history[#_history][i] = v
	end,
})


local p = Instance.new('Part', workspace.CurrentCamera)
p.Anchored = true
p.CanCollide = false
p.Material = Enum.Material.ForceField
p.Shape = Enum.PartType.Ball
p.Size = Vector3.new(2,2,2)*_G.saveRadius
p.Color = Color3.new(.1, 1, .1)
p.CFrame = CFrame.new(base.CFrame.Position)
local ppos = base.CFrame.Position

mouse.Button1Down:Connect(function()
	if uis:IsKeyDown(Enum.KeyCode.LeftControl) then
		--print'resetting')
		base = mouse.Target
		table.clear(history.recorded)
		table.clear(history.names) 
		table.clear(history.placed )
		table.clear(history.attachPoints)
		for i, v in pairs(_history) do
			if i ~= 0 then
				_history[i] = nil
			end
		end
		_history[0] = {part = base, recorded={}, names = {}, attachPoints = {}, placed = {} }

		game.Debris:AddItem(p, 0)

		p = Instance.new('Part', workspace.CurrentCamera)
		p.Anchored = true
		p.CanCollide = false
		p.Material = Enum.Material.ForceField
		p.Shape = Enum.PartType.Ball
		p.Size = Vector3.new(2,2,2)*_G.saveRadius
		p.Color = Color3.new(.1, 1, .1)
		p.CFrame = CFrame.new(base.CFrame.Position)
		ppos = base.CFrame.Position
	end
end)
mouse.KeyDown:Connect(function(k)
	if k == 'r' and uis:IsKeyDown(Enum.KeyCode.LeftControl) then
		recording = not recording
		local msg = Instance.new("Message", workspace.CurrentCamera)
		msg.Text = tostring(recording)
		game.Debris:AddItem(msg, .5)
	elseif k == 'z' and uis:IsKeyDown(Enum.KeyCode.LeftControl) then
		undo()
	end
end)

local addnew = function(v, i)
	local val = v[i]
	if val~= nil then
		return ','..tostring(val)
	else
		return ',n'
	end
end

getRecorded = function()
	local s = [[
local n
local cf = function(xp, yp, zp, xr, yr, zr)
	return cfn(xp, yp, zp)*cfa(xr,yr,zr)
end
cfn, cfa = CFrame.new, CFrame.fromEulerAnglesYXZ
local tbl = {
]]
	for i, v in ipairs(history.recorded) do
		s..='{'
		--s..=v[1]..',cf('..cfToString(v[2])..')'..addnew(v,3,7)
		s..=v[1]..',cf('..cfToString(v[2])..')'..addnew(v,3)..addnew(v,4)..addnew(v,5)..addnew(v,6)..addnew(v,7)
		s..='},'
	end
	s..='}'

	local namestring = 'names = {'
	for i, v in ipairs(history.names) do
		--print'tostringing names', i, v)
		namestring..="'".. v.."',"
	end
	namestring..=[[};
]]

	local namestring2 = 'attachments = {'
	for i, v in ipairs(history.attachPoints) do
		namestring2..="'".. v.."',"
	end
	namestring2..=[[};
]]
	setclipboard(stringReplace( namestring..namestring2..s, ',n', ''))
end


saveMethods = {
	other = function(data, nameIndex)
		local cf = data.CFrame
		local partBase = data.BasePart

		table.insert(history.recorded, {
			nameIndex, base.CFrame:ToObjectSpace(partBase.CFrame*cf), 0
		})
	end,
	Cap = function(data, nameIndex)
		local cf = data.CFrame
		local partBase = data.BasePart

		local attachIndex = table.find(history.attachPoints, partBase.Name)
		if not attachIndex then
			attachIndex = #history.attachPoints+1
			history.attachPoints[attachIndex] = partBase.Name
		end
		local parentIndex = nil
		for i, v in pairs(history.placed) do
			if v:IsAncestorOf(partBase) then
				parentIndex = i
				break
			end
		end

		table.insert(history.recorded, {
			nameIndex, cf, 1, attachIndex, parentIndex
		})
	end,
	['Four-Way'] = function(data, nameIndex, args)

		if #args == 2 then
			return saveMethods.other(data, nameIndex)
		end

		local cf = data.CFrame
		local partBase = data.BasePart

		local attachIndex = table.find(history.attachPoints, partBase.Name)
		if not attachIndex then
			attachIndex = #history.attachPoints+1
			history.attachPoints[attachIndex] = partBase.Name
		end

		local localattachIndex = table.find(history.attachPoints, args[3])
		if not localattachIndex then
			localattachIndex = #history.attachPoints+1
			history.attachPoints[localattachIndex] = args[3]
		end

		local parentIndex = nil
		for i, v in pairs(history.placed) do
			if v:IsAncestorOf(partBase) then
				parentIndex = i
				break
			end
		end

		table.insert(history.recorded, {
			nameIndex, cf, 1, attachIndex, parentIndex, localattachIndex
		})

	end,
	Pipe = function(data, nameIndex, args)
		local placementData = args[2]
		local point1 = placementData[1]
		local point2 = placementData[2]

		if point1.BasePart and point2.BasePart then-- from land to land
			table.insert(history.recorded, {
				nameIndex, base.CFrame:ToObjectSpace(point1.BasePart.CFrame*point1.CFrame ), 4, cfToString2( base.CFrame:ToObjectSpace(point2.BasePart.CFrame*point2.CFrame) )
			})
		elseif point1.SnapPart and point2.BasePart or point1.BasePart and point2.SnapPart then -- from something to land
			if point1.BasePart and point2.SnapPart then
				local cache = point1
				point1 = point2
				point2 = cache
			end
			
			local attachIndex1 = table.find(history.attachPoints, point1.SnapPart.Name)
			if not attachIndex1 then
				attachIndex1 = #history.attachPoints+1
				history.attachPoints[attachIndex1] = point1.SnapPart.Name
			end
			local attachPartIndex
			for i, v in pairs(history.placed) do
				if v:IsAncestorOf(point1.SnapPart) then
					attachPartIndex = i
					break
				end
			end
			
			table.insert(history.recorded, {
				nameIndex, base.CFrame:ToObjectSpace(point2.BasePart.CFrame*point2.CFrame ), 5, attachIndex1, attachPartIndex
			})
		else-- from snap to snap
			local attachIndex1 = table.find(history.attachPoints, point1.SnapPart.Name)
			if not attachIndex1 then
				attachIndex1 = #history.attachPoints+1
				history.attachPoints[attachIndex1] = point1.SnapPart.Name
			end
			local attachIndex2 = table.find(history.attachPoints, point2.SnapPart.Name)
			if not attachIndex2 then
				attachIndex2 = #history.attachPoints+1
				history.attachPoints[attachIndex2] = point2.SnapPart.Name
			end

			local snapPart1
			for i, v in pairs(history.placed) do
				if v:IsAncestorOf(point1.SnapPart) then
					snapPart1 = i
					break
				end
			end
			local snapPart2
			for i, v in pairs(history.placed) do
				if v:IsAncestorOf(point2.SnapPart) then
					snapPart2 = i
					break
				end
			end

			table.insert(history.recorded, {
				nameIndex, CFrame.new(), 6, snapPart1, attachIndex1, snapPart2, attachIndex2
			})
		end
	end,
}

local pipes = {'T-Junction', 'Elbow', 'Elbow', 'Wall', 'Keep', 'Gate', 'Block', 'HollowBlock', 'Platform Block', 'Slab Block', 'Ladder Block', 'Wedge 30', 'Wedge 45', 'Bridge', 'Valve', 'Gauge'}
for i, v in ipairs(pipes) do
	saveMethods[v] = saveMethods["Four-Way"]
end
saveMethods['Distributor Cap'] = saveMethods.Cap




local old;old  = hookmetamethod(game, "__namecall", function(self, ...)
	local args = {...}
	local method = getnamecallmethod()

	if searching == true and self == remote and method == 'FireServer' then return end 

	task.spawn(function()
		if not checkcaller() and self == remote and method == 'FireServer' then
			
			if history.part ~= nil then setHistoryStep(history.part) end
			
			local name = args[1]
			local data = args[2]
			local nameIndex = table.find(history.names, name)
			if not nameIndex then
				nameIndex = #history.names+1
				if recording then
					history.names[nameIndex] = name
				end
			end
			local found, s = false, os.clock()+60
			local con; con = structures.ChildAdded:Connect(function(nigger)
				task.wait()
				if nigger.Name == name and nigger:GetAttribute('MaxHealth') then
					local ss = os.clock()+1
					while nigger.PrimaryPart == nil and os.clock()<ss do wait() if _G.stop == true then break end end
					if ( (nigger.PrimaryPart and nigger.PrimaryPart.Position or nigger:GetPivot().Position) -ppos).Magnitude <= _G.saveRadius then
						found = nigger
					end
				end
			end)	
			searching = true
			while found == false and os.clock()<s do wait() if _G.stop == true then break end  end
			searching = false
			con:Disconnect()
			if found then
				if recording == true then
					
					table.insert(history.placed, found);
					( saveMethods[name] or saveMethods['other'] ) (data, nameIndex, args)
					
					history.part = found
					getRecorded()
					
				else
					wait(6)
					for ii, vv in ipairs(found:GetDescendants()) do
						if vv:IsA('BasePart') then
							vv.Color = vv.Color:Lerp( Color3.new(1,0,0), .5 )
						end
					end
				end
			end
		end
	end)

	return old(self, ...)
end)




warn('done')
